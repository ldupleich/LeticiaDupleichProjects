// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/2/ALU.hdl
/**
 * ALU (Arithmetic Logic Unit):
 * Computes out = one of the following functions:
 *                0, 1, -1,
 *                x, y, !x, !y, -x, -y,
 *                x + 1, y + 1, x - 1, y - 1,
 *                x + y, x - y, y - x,
 *                x & y, x | y
 * on the 16-bit inputs x, y,
 * according to the input bits zx, nx, zy, ny, f, no.
 * In addition, computes the two output bits:
 * if (out == 0) zr = 1, else zr = 0
 * if (out < 0)  ng = 1, else ng = 0
 */
// Implementation: Manipulates the x and y inputs
// and operates on the resulting values, as follows:
// if (zx == 1) sets x = 0        // 16-bit constant
// if (nx == 1) sets x = !x       // bitwise not
// if (zy == 1) sets y = 0        // 16-bit constant
// if (ny == 1) sets y = !y       // bitwise not
// if (f == 1)  sets out = x + y  // integer 2's complement addition
// if (f == 0)  sets out = x & y  // bitwise and
// if (no == 1) sets out = !out   // bitwise not

CHIP ALU {
    IN  
        x[16], y[16],  // 16-bit inputs        
        zx, // zero the x input?
        nx, // negate the x input?
        zy, // zero the y input?
        ny, // negate the y input?
        f,  // compute (out = x + y) or (out = x & y)?
        no; // negate the out output?
    OUT 
        out[16], // 16-bit output
        zr,      // if (out == 0) equals 1, else 0
        ng;      // if (out < 0)  equals 1, else 0

    PARTS:
    // If (zx == 1) sets x = 0
    Mux16(a=x , b=false , sel=zx , out=xzero );

    // If (nx == 1) sets x = !x. Here we need to first negate the value of x
    // and then use it in the Mux16 chip (if conditional).
    Not16(in=xzero , out=xnot );
    Mux16(a=xzero , b=xnot , sel=nx , out=xval );

    // If (zy == 1) sets y = 0
    Mux16(a=y , b=false , sel=zy , out=yzero );

    // If (ny == 1) sets y = !y. Here we need to first negate the value of y
    // and then use it in the Mux16 chip (if conditional).
    Not16(in=yzero , out=ynot );
    Mux16(a=yzero , b=ynot , sel=ny , out=yval );

    // If (f == 1)  sets out = x + y 
    // If (f == 0)  sets out = x & y 
    // We first compute both values that might be possible, the addition or the
    // conjunction. Then we use this in Mux16 to determine which to use depending
    // on the value of f.

    Add16(a=xval , b=yval , out=xaddy );
    And16(a=xval , b=yval , out=xandy );
    Mux16(a=xandy , b=xaddy , sel=f , out=outval );
    
    // If (no == 1) sets out = !out 

    // Setting ng to 1 if (out < 0)  equals 1, else 0. This happens (out < 0),
    // when the most significant bit (out[15]) is 1. So, we can simply set 
    // ng to be the value of out[15]. 

    // Setting zr to 1 if (out == 0) equals 1, else 0. To determine if out is 0,
    // we have to see if there are no 1s. Since we have an implementation of Or
    // that can compare 8 bits, namely Or8Way, we can use it twice for the lower
    // and upper values of out. If the overall value of Or is true, then a 1 has
    // been found and or is not zero, so zr is 0.

    Not16(in=outval , out=notout );
    Mux16(a=outval, b=notout, sel=no, out=out, out[15]=ng, out[0..7]=lower, out[8..15]=upper);
    Or8Way(in=lower, out=low);
    Or8Way(in=upper, out=high);
    Or(a=low, b=high, out=notzero);
    Not(in=notzero, out=zr);

    
}